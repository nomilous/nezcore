// Generated by CoffeeScript 1.6.3
var afterHooks, beforeHooks, defer, injector, sequence;

sequence = require('when/sequence');

defer = require('when').defer;

beforeHooks = {
  each: [],
  all: []
};

afterHooks = {
  each: [],
  all: []
};

Object.defineProperty(global, 'before', {
  enumerable: false,
  get: function() {
    return function(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof opts.each === 'function') {
        beforeHooks.each.push(opts.each);
      }
      if (typeof opts.all === 'function') {
        return beforeHooks.all.push(opts.all);
      }
    };
  }
});

Object.defineProperty(global, 'after', {
  enumerable: false,
  get: function() {
    return function(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof opts.each === 'function') {
        afterHooks.each.push(opts.each);
      }
      if (typeof opts.all === 'function') {
        return afterHooks.all.push(opts.all);
      }
    };
  }
});

module.exports = injector = {
  runHooks: function(hookType, stack, done) {
    var phrase;
    return sequence((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stack.length; _i < _len; _i++) {
        phrase = stack[_i];
        _results.push((function(phrase) {
          return function() {
            var deferral;
            deferral = defer();
            phrase[hookType](deferral.resolve);
            return deferral.promise;
          };
        })(phrase));
      }
      return _results;
    })()).then(done, done);
  },
  beforeAll: function(opts, control) {
    return function(done, inject) {
      var afterAll, afterEach, beforeAll, beforeEach;
      beforeEach = beforeHooks.each.pop();
      beforeAll = beforeHooks.all.pop();
      afterEach = afterHooks.each.pop();
      afterAll = afterHooks.all.pop();
      control.beforeEach || (control.beforeEach = beforeEach);
      control.beforeAll || (control.beforeAll = beforeAll);
      control.afterEach || (control.afterEach = afterEach);
      control.afterAll || (control.afterAll = afterAll);
      if (typeof control.beforeAll === 'function') {
        if (!opts.global) {
          return control.beforeAll.call(this, done);
        }
        return control.beforeAll.call(null, done);
      }
      return done();
    };
  },
  beforeEach: function(opts, control) {
    return function(done, inject) {
      var argCount, element;
      if (typeof inject.args[2] !== 'function') {
        argCount = inject.args.length;
        inject.args[2] = inject.args[1] || function() {
          if (argCount === 0) {
            opts.stack.pop();
            return control.defer.resolve();
          }
        };
        if (argCount === 1) {
          'noop';
        }
        inject.args[1] = {};
      }
      inject.args[1].defer = inject.defer;
      opts.stack.push(element = {
        element: opts.elementName,
        phrase: inject.args[0],
        defer: inject.defer,
        queue: inject.queue,
        current: inject.current,
        beforeEach: control.beforeEach || function(done) {
          return done();
        },
        afterEach: control.afterEach || function(done) {
          return done();
        }
      });
      if (opts.context.leafOnly) {
        return opts.context.isLeaf({
          element: opts.elementName,
          phrase: inject.args[0],
          fn: inject.args[2]
        }, function(leaf) {
          if (leaf) {
            element.leaf = true;
            return injector.runHooks('beforeEach', opts.stack, done);
          }
          return done();
        });
      } else if (typeof control.beforeEach === 'function') {
        if (!control.global) {
          return control.beforeEach(done);
        }
        return control.beforeEach.call(null, done);
      } else {
        return done();
      }
    };
  },
  afterEach: function(opts, control) {
    return function(done, inject) {
      var element;
      element = opts.stack[opts.stack.length - 1];
      return sequence([
        function() {
          var phrase, reversed, step, _i, _len, _ref;
          if (!element.leaf) {
            return;
          }
          step = defer();
          reversed = [];
          _ref = opts.stack;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            phrase = _ref[_i];
            reversed.unshift(phrase);
          }
          injector.runHooks('afterEach', reversed, function(result) {
            return step.resolve(result);
          });
          return step.promise;
        }
      ]).then(done, done);
    };
  },
  afterAll: function(opts, control) {
    return function(done, inject) {
      if (typeof control.afterAll === 'function') {
        if (!control.global) {
          return control.afterAll.call(this, done);
        }
        return control.afterAll.call(null, done);
      }
      return done();
    };
  }
};
