// Generated by CoffeeScript 1.6.3
var afterHooks, beforeHooks, defer, deferral, injector, sequence, util, _ref;

sequence = require('when/sequence');

defer = require('when').defer;

_ref = require('also'), deferral = _ref.deferral, util = _ref.util;

beforeHooks = {
  each: [],
  all: []
};

afterHooks = {
  each: [],
  all: []
};

Object.defineProperty(global, 'before', {
  enumerable: false,
  get: function() {
    return function(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof opts.each === 'function') {
        beforeHooks.each.push(opts.each);
      }
      if (typeof opts.all === 'function') {
        return beforeHooks.all.push(opts.all);
      }
    };
  }
});

Object.defineProperty(global, 'after', {
  enumerable: false,
  get: function() {
    return function(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof opts.each === 'function') {
        afterHooks.each.push(opts.each);
      }
      if (typeof opts.all === 'function') {
        return afterHooks.all.push(opts.all);
      }
    };
  }
});

module.exports = injector = {
  runHooks: function(hookType, stack, done) {
    var phrase;
    return sequence((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stack.length; _i < _len; _i++) {
        phrase = stack[_i];
        _results.push((function(phrase) {
          return deferral.optional({
            resolver: 'done'
          }, phrase[hookType]);
        })(phrase));
      }
      return _results;
    })()).then(done, done);
  },
  onTimeout: function(opts, control) {
    return function(done, detail, inject) {
      if (opts.context.handler != null) {
        if (typeof opts.context.handler.onTimeout === 'function') {
          return opts.context.handler.onTimeout(done, detail, pushFn);
        }
      }
      return done();
    };
  },
  beforeAll: function(opts, control) {
    return function(done, inject) {
      var afterAll, afterEach, beforeAll, beforeEach, promise;
      beforeEach = beforeHooks.each.pop();
      beforeAll = beforeHooks.all.pop();
      afterEach = afterHooks.each.pop();
      afterAll = afterHooks.all.pop();
      control.beforeEach || (control.beforeEach = beforeEach);
      control.beforeAll || (control.beforeAll = beforeAll);
      control.afterEach || (control.afterEach = afterEach);
      control.afterAll || (control.afterAll = afterAll);
      if (typeof control.beforeAll !== 'function') {
        return done();
      }
      promise = deferral.optional({
        resolver: 'done',
        context: opts.context.global ? null : this
      }, control.beforeAll);
      return promise().then(function() {
        return done();
      });
    };
  },
  beforeEach: function(opts, control) {
    return function(done, inject) {
      var argCount, element, promise;
      if (typeof inject.args[2] !== 'function') {
        argCount = inject.args.length;
        inject.args[2] = inject.args[1] || function() {
          if (argCount === 0) {
            opts.stack.pop();
            return control.defer.resolve();
          }
        };
        if (argCount === 1) {
          'noop';
        }
        inject.args[1] = {};
      }
      inject.args[1].defer = inject.defer;
      opts.stack.push(element = {
        element: opts.elementName,
        phrase: inject.args[0],
        defer: inject.defer,
        queue: inject.queue,
        current: inject.current,
        beforeEach: control.beforeEach || function(done) {
          return done();
        },
        afterEach: control.afterEach || function(done) {
          return done();
        }
      });
      if (opts.context.leafOnly) {
        opts.context.isLeaf({
          element: opts.elementName,
          phrase: inject.args[0],
          fn: inject.args[2]
        }, function(leaf) {
          if (leaf) {
            element.leaf = true;
            return injector.runHooks('beforeEach', opts.stack, done);
          }
          return done();
        });
        return;
      }
      if (typeof control.beforeEach !== 'function') {
        return done();
      }
      promise = deferral.optional({
        resolver: 'done',
        context: opts.context.global ? null : this
      }, control.beforeEach);
      return promise().then(function() {
        return done();
      });
    };
  },
  afterEach: function(opts, control) {
    return function(done, inject) {
      var element, target;
      element = opts.stack[opts.stack.length - 1];
      target = opts.context.global ? null : this;
      return sequence([
        function() {
          var phrase, reversed, step, _i, _len, _ref1;
          if (element == null) {
            return;
          }
          if (!element.leaf) {
            return;
          }
          step = defer();
          reversed = [];
          _ref1 = opts.stack;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            phrase = _ref1[_i];
            reversed.unshift(phrase);
          }
          injector.runHooks('afterEach', reversed, function(result) {
            return step.resolve(result);
          });
          return step.promise;
        }, function() {
          return opts.stack.pop();
        }, function() {
          var promise;
          if (opts.context.leafOnly) {
            return;
          }
          if (typeof control.afterEach !== 'function') {
            return;
          }
          promise = deferral.optional({
            resolver: 'done',
            context: target
          }, control.afterEach);
          return promise();
        }
      ]).then(function() {
        return done();
      });
    };
  },
  afterAll: function(opts, control) {
    return function(done, inject) {
      var finished, promise;
      finished = function() {
        done();
        return process.nextTick(function() {
          var parent;
          if (opts.stack.length > 0) {
            parent = opts.stack[opts.stack.length - 1];
            return parent.defer.resolve();
          }
          if (typeof opts.context.done === 'function') {
            return opts.context.done();
          }
        });
      };
      if (typeof control.afterAll !== 'function') {
        return finished();
      }
      promise = deferral.optional({
        resolver: 'done',
        context: opts.context.global ? null : this
      }, control.afterAll);
      return promise().then(function() {
        return finished();
      });
    };
  }
};
