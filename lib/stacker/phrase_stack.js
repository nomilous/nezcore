// Generated by CoffeeScript 1.6.3
var LeafDetect, afterHooks, argsOf, async, beforeHooks, defer, sequence;

argsOf = require('also').util.argsOf;

async = require('also').inject.async;

defer = require('when').defer;

sequence = require('when/sequence');

LeafDetect = require('./phrase_leaf_detect');

beforeHooks = {
  each: [],
  all: []
};

afterHooks = {
  each: [],
  all: []
};

if (typeof Object.prototype.before === 'undefined') {
  Object.defineProperty(Object.prototype, 'before', {
    enumerable: false,
    get: function() {
      return function(opts) {
        if (opts == null) {
          opts = {};
        }
        if (typeof opts.each === 'function') {
          beforeHooks.each.push(opts.each);
        }
        if (typeof opts.all === 'function') {
          return beforeHooks.all.push(opts.all);
        }
      };
    }
  });
}

if (typeof Object.prototype.after === 'undefined') {
  Object.defineProperty(Object.prototype, 'after', {
    enumerable: false,
    get: function() {
      return function(opts) {
        if (typeof opts.each === 'function') {
          afterHooks.each.push(opts.each);
        }
        if (typeof opts.all === 'function') {
          return afterHooks.all.push(opts.all);
        }
      };
    }
  });
}

module.exports = {
  create: function(context, notice, realizerFn) {
    var runHooks, stack, stacker;
    stack = [];
    context.isLeaf || (context.isLeaf = LeafDetect["default"]);
    runHooks = function(hookType, stack, done) {
      var phrase;
      return sequence((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          phrase = stack[_i];
          _results.push((function(phrase) {
            return function() {
              var deferral;
              deferral = defer();
              phrase[hookType](deferral.resolve);
              return deferral.promise;
            };
          })(phrase));
        }
        return _results;
      })()).then(done, done);
    };
    stacker = function(elementName, control) {
      var pushFn;
      pushFn = async({
        parallel: false,
        timeout: control.timeout || 0,
        onError: function(error) {
          return console.log(error.stack);
        },
        onTimeout: function(done, detail, inject) {
          if (context.handler != null) {
            if (typeof context.handler.onTimeout === 'function') {
              return context.handler.onTimeout(done, detail, pushFn);
            }
          }
          return done();
        },
        beforeAll: function(done) {
          var afterAll, afterEach, beforeAll, beforeEach;
          beforeEach = beforeHooks.each.pop();
          beforeAll = beforeHooks.all.pop();
          afterEach = afterHooks.each.pop();
          afterAll = afterHooks.all.pop();
          control.beforeEach || (control.beforeEach = beforeEach);
          control.beforeAll || (control.beforeAll = beforeAll);
          control.afterEach || (control.afterEach = afterEach);
          control.afterAll || (control.afterAll = afterAll);
          if (typeof control.beforeAll === 'function') {
            if (!control.global) {
              return control.beforeAll(done);
            }
            return control.beforeAll.call(null, done);
          }
          return done();
        },
        beforeEach: function(done, inject) {
          var element;
          if (typeof inject.args[2] !== 'function') {
            inject.args[2] = inject.args[1] || function() {
              control.defer.resolve();
              return stack.pop();
            };
            inject.args[1] = {};
          }
          inject.args[1].defer = inject.defer;
          stack.push(element = {
            element: elementName,
            phrase: inject.args[0],
            defer: inject.defer,
            queue: inject.queue,
            current: inject.current,
            beforeEach: control.beforeEach || function(done) {
              return done();
            },
            afterEach: control.afterEach || function(done) {
              return done();
            }
          });
          if (control.leafOnly) {
            return context.isLeaf({
              element: elementName,
              phrase: inject.args[0],
              fn: inject.args[2]
            }, function(leaf) {
              if (leaf) {
                element.leaf = true;
                return runHooks('beforeEach', stack, done);
              }
              return done();
            });
          } else if (typeof control.beforeEach === 'function') {
            if (!control.global) {
              return control.beforeEach(done);
            }
            return control.beforeEach.call(null, done);
          } else {
            return done();
          }
        },
        afterEach: function(done, inject) {
          var element;
          element = stack[stack.length - 1];
          return sequence([
            function() {
              var phrase, reversed, step, _i, _len;
              if (!element.leaf) {
                return;
              }
              step = defer();
              reversed = [];
              for (_i = 0, _len = stack.length; _i < _len; _i++) {
                phrase = stack[_i];
                reversed.unshift(phrase);
              }
              runHooks('afterEach', reversed, function(result) {
                return step.resolve(result);
              });
              return step.promise;
            }, function() {
              return stack.pop();
            }, function() {
              var step;
              if (control.leafOnly) {
                return;
              }
              if (typeof control.afterEach !== 'function') {
                return;
              }
              step = defer();
              if (control.global) {
                return control.afterEach(function(result) {
                  return step.resolve(result);
                });
              }
              return control.afterEach.call(null, function(result) {
                return step.resolve(result);
              });
              return step.promise;
            }
          ]).then(function() {
            done();
            if (element.queue.remaining === 0) {
              return process.nextTick(function() {
                var parent;
                parent = stack[stack.length - 1];
                if (parent != null) {
                  return parent.defer.resolve();
                }
              });
            }
          });
        },
        afterAll: function(done, inject) {
          if (typeof control.afterAll === 'function') {
            if (!control.global) {
              return control.afterAll(done);
            }
            return control.afterAll.call(null, done);
          }
          return done();
        }
      }, function(phrase, nestedControl, fn) {
        var childElementName;
        childElementName = argsOf(fn)[0];
        nestedControl.global = control.global;
        nestedControl.leafOnly = control.leafOnly;
        return fn(stacker(childElementName, nestedControl));
      });
      Object.defineProperty(pushFn, 'stack', {
        get: function() {
          return stack;
        },
        enumerable: false
      });
      Object.defineProperty(pushFn, 'top', {
        get: function() {
          return stack[stack.length - 1];
        },
        enumerable: false
      });
      return pushFn;
    };
    return stacker(argsOf(realizerFn)[0], context);
  }
};
