// Generated by CoffeeScript 1.6.3
var argsOf, async;

argsOf = require('also').util.argsOf;

async = require('also').inject.async;

module.exports = {
  create: function(context, notice, realizerFn, tester) {
    var hooks, popHook, pushHook, runHooks, stack, stacker;
    stack = [];
    context.isLeaf || (context.isLeaf = function(params, isLeaf) {
      return isLeaf(true);
    });
    hooks = {};
    pushHook = function(hookType, control) {};
    runHooks = function(hookType, control, done) {
      return done();
    };
    popHook = function(hookType) {};
    stacker = function(elementName, control) {
      var pushFn;
      pushFn = async({
        parallel: false,
        timeout: control.timeout || 0,
        error: function(error) {
          return console.log(error.stack);
        },
        beforeAll: function(done) {
          if (typeof control.beforeAll === 'function') {
            if (!control.global) {
              return control.beforeAll(done);
            }
            return control.beforeAll.call(null, done);
          }
          return done();
        },
        beforeEach: function(done, inject) {
          if (typeof inject.args[2] !== 'function') {
            inject.args[2] = inject.args[1] || function() {
              control.defer.resolve();
              return stack.pop();
            };
            inject.args[1] = {};
          }
          inject.args[1].defer = inject.defer;
          stack.push({
            element: elementName,
            phrase: inject.args[0],
            defer: inject.defer,
            queue: inject.queue,
            current: inject.current,
            beforeEach: control.beforeEach,
            afterEach: control.afterEach
          });
          if (control.leafOnly) {
            pushHook('beforeEach', control);
            return context.isLeaf({
              element: elementName,
              phrase: inject.args[0],
              fn: inject.args[2]
            }, function(leaf) {
              if (leaf) {
                control.leaf = true;
                console.log({
                  LEAF: {
                    element: elementName,
                    phrase: inject.args[0]
                  }
                });
                return runHooks('beforeEach', control, done);
              }
              return done();
            });
          } else if (typeof control.beforeEach === 'function') {
            if (!control.global) {
              return control.beforeEach(done);
            }
            return control.beforeEach.call(null, done);
          } else {
            return done();
          }
        },
        afterEach: function(done, inject) {
          var element, parent;
          if (inject.current.timeout) {
            pushFn.timeout = true;
            if (typeof tester === 'function') {
              tester(pushFn);
            }
          }
          element = stack.pop();
          if (element.queue.remaining === 0) {
            parent = stack[stack.length - 1];
            if (parent != null) {
              parent.defer.resolve();
            }
            if (parent == null) {
              if (context.done != null) {
                context.done();
              }
              done();
            }
          }
          if (control.leaf) {
            pushHook('afterEach', control);
            return runHooks('afterEach', control, done);
          } else if (typeof control.afterEach === 'function') {
            if (!control.global) {
              return control.afterEach(done);
            }
            return control.afterEach.call(null, done);
          }
          return done();
        },
        afterAll: function(done, inject) {
          if (typeof control.afterAll === 'function') {
            if (!control.global) {
              return control.afterAll(done);
            }
            return control.afterAll.call(null, done);
          }
          return done();
        }
      }, function(phrase, nestedControl, fn) {
        var childElementName;
        childElementName = argsOf(fn)[0];
        nestedControl.global = control.global;
        nestedControl.leafOnly = control.leafOnly;
        return fn(stacker(childElementName, nestedControl));
      });
      Object.defineProperty(pushFn, 'stack', {
        get: function() {
          return stack;
        },
        enumerable: false
      });
      Object.defineProperty(pushFn, 'top', {
        get: function() {
          return stack[stack.length - 1];
        },
        enumerable: false
      });
      return pushFn;
    };
    return stacker(argsOf(realizerFn)[0], context);
  }
};
