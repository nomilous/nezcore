// Generated by CoffeeScript 1.4.0
var Inflection, fs, support, wrench;

Inflection = require('inflection');

wrench = require('wrench');

fs = require('fs');

require('fing');

module.exports = support = {
  fn2modules: function(fn) {
    var arg, funcStr, module, modules, _i, _len, _ref;
    modules = [];
    funcStr = fn.toString();
    _ref = fn.fing.args;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      module = arg.name;
      if (module.match(/^_arg/)) {
        if (funcStr.match(/_ref = _arg/)) {
          support.mixedDepth(modules, funcStr);
        } else {
          support.uniformDepth(modules, funcStr);
        }
      } else {
        modules.push({
          module: arg.name
        });
      }
    }
    return modules;
  },
  mixedDepth: function(modules, funcStr) {
    throw new Error('Mixed depth focussed injection not yet supported');
  },
  uniformDepth: function(modules, funcStr) {
    var chain, narg, nargs, nestings, ref, regexp, targetArg, _i, _len;
    nestings = {};
    nargs = funcStr.match(/_(arg|ref)\.(\w*)/g);
    for (_i = 0, _len = nargs.length; _i < _len; _i++) {
      narg = nargs[_i];
      chain = narg.split('.');
      ref = chain.shift();
      regexp = new RegExp("(\\w*) = _arg." + chain[0]);
      targetArg = funcStr.match(regexp)[1];
      funcStr = funcStr.replace(regexp, '');
      if (chain[chain.length - 1] !== targetArg) {
        chain.push(targetArg);
      }
      nestings[targetArg] = chain;
    }
    return modules.push({
      _nested: nestings
    });
  },
  loadServices: function(dynamic, preDefined) {
    var config, services, skip, _i, _len;
    if (preDefined == null) {
      preDefined = [];
    }
    skip = preDefined.length;
    services = preDefined;
    for (_i = 0, _len = dynamic.length; _i < _len; _i++) {
      config = dynamic[_i];
      if (skip-- > 0) {
        continue;
      }
      if (config._nested) {
        support.loadNested(services, config._nested);
        continue;
      }
      services.push(support.findModule(config));
    }
    return services;
  },
  loadNested: function(services, config) {
    var chain, className, moduleName, modules, sequence, target, _arg;
    modules = {};
    sequence = [];
    _arg = {};
    for (target in config) {
      chain = config[target];
      moduleName = chain[0];
      className = chain[1];
      sequence.push(moduleName);
      if (typeof modules[moduleName] === 'undefined') {
        modules[moduleName] = {
          module: support.findModule({
            module: moduleName
          }),
          stack: []
        };
        Object.defineProperty(_arg, moduleName, {
          get: function() {
            return modules[sequence.shift()].stack.pop();
          },
          enumerable: true
        });
      }
      if (typeof className === 'undefined') {
        modules[moduleName].stack.unshift(modules[moduleName].module);
      } else {
        modules[moduleName].stack.unshift(modules[moduleName].module[className]);
      }
    }
    services.push(_arg);
    return services;
  },
  findModule: function(config) {
    var file, line, match, modulePath, name, parts, path, previous, _i, _len, _ref;
    if (!config.module.match(/^[A-Z]/)) {
      return require(config.module);
    }
    name = Inflection.underscore(config.module);
    previous = null;
    _ref = Error.apply(this).stack.split('\n');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (line === 'Error') {
        continue;
      }
      if (line.match(/unknown source/)) {
        continue;
      }
      try {
        parts = line.match(/\((.*)\:\d*\:\d*/);
        if (!parts) {
          parts = line.match(/\W*at (.*)\:\d*\:\d*/);
        }
        file = parts[1];
      } catch (error) {
        throw 'error parsing stack trace ' + error;
        continue;
      }
      if (match = file.match(/(.*)\/spec\/.*/)) {
        path = match[1];
        modulePath = support.getModulePath(name, path, ['lib', 'app', 'bin']);
        if (modulePath) {
          return require(modulePath);
        }
        throw new Error("Injector failed to locate " + name + ".js in " + path);
      }
      if (file.match(/injector_support.js$/)) {
        continue;
      } else if (file === 'module.js') {
        if (match = previous.match(/(.*)\/(lib|app|bin)\//)) {
          path = match[1];
          modulePath = support.getModulePath(name, match[1], [match[2]]);
          if (modulePath) {
            return require(modulePath);
          }
          throw new Error("Injector failed to locate " + name + ".js in " + path);
        }
        continue;
      }
      previous = file;
    }
    throw new Error("Injector failed to locate " + name + ".js");
  },
  getModulePath: function(name, root, search) {
    var dir, expression, file, match, searchPath, source, _i, _j, _len, _len1, _ref;
    expression = "(.*" + name + ")\\.(coffee|js)$";
    for (_i = 0, _len = search.length; _i < _len; _i++) {
      dir = search[_i];
      source = null;
      searchPath = root + ("/" + dir);
      if (fs.existsSync(searchPath)) {
        _ref = wrench.readdirSyncRecursive(searchPath);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          file = _ref[_j];
          if (match = file.match(new RegExp(expression))) {
            if (match[1].split('/').pop() !== name) {
              continue;
            }
            if (source) {
              throw new Error("Found more than 1 source for module '" + name + "'");
            } else {
              source = "" + searchPath + "/" + match[1];
            }
          }
        }
      }
      return source;
    }
  }
};
